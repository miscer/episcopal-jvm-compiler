---
title: CS4201 Practical 1
author: 140015533
date: 3 November 2017
toc: true
---

# Design

## Distributions and samples

Discrete distributions and samples

Continuous distributions and samples

Operators
- adding/comparing two discrete samples
- adding continuous samples
- comparing continuous samples (equal, less than, greater than)

Observations

## Abstract syntax

Identifiers and function calls were merged into one expression type, function call.

The bracketing expression is not included in the abstract tree, as it can be handled by the parser alone.

Function and distribution definition were merged into one, since every function already returns a sample. New distributions can be defined as functions that return a sample, instead of creating a new distribution and sampling it. However, if there was any other operation that can be done with a distribution (other than sampling), it would make sense to have a separate distribution definition type.

The probability constant does not exist in the abstract syntax, as it is essentially the same as a floating point constant. For example 95% is equal to 0.95, and this conversion can be handled by the parser.

# Implementation

## Standard library

The logic of the language described above is implemented in Java. There are classes for the four distributions, discrete and continuous samples, operators and observations.

These classes are not tied to the compiler and can by used by any other application.

The standard library needs to be compiled to JVM bytecode and made available to the compiled Episcopal program.

## Runtime

The compiled programs do not interact with the standard library directly. This is because it is simply not possible. For example, the add method in the `Operators` class in the standard library takes two distributions as arguments and returns another distribution. There are separate methods for adding integers and floats:

```
public static DiscreteSample<Integer> addIntegers(DiscreteSample<Integer> left, DiscreteSample<Integer> right);
public static DiscreteSample<Float> addFloats(DiscreteSample<Float> left, DiscreteSample<Float> right);
```

However when compiling the episcopal program, the compiler only sees that the operator is applied to two expressions:

```
ExpOp OpAdd expr1 expr2
```

These two expression can contain anything, for example a distribution and a local definition. It cannot know whether to use `addIntegers` or `addFloats`. We could use the `instaceof` operator to try and find out the type of the expression at runtime, but this does not work with discrete samples, which use generics, as the exact type is removed during compilation from Java.

Therefore we need a layer between the compiled bytecode and the standard library. This exists in the `Runtime` and `RuntimeValue` classes.

`RuntimeValue` wraps all values in the program: discrete and continuous samples and distributions. The type of the value is stored in a field and can be accessed by other classes.

`Runtime` then works with `RuntimeValue` instances by providing methods for various episcopal commands, such as sampling or comparing two values. These methods take runtime values as arguments and return another runtime value.

This way the bytecode generated by the compiler doesn't deal with types of values - it simply translates expressions into calls to `Runtime` methods.

The `Runtime` class then executes methods in the standard library based on the types of runtime values it receives. If the two types do not make sense (e.g. adding a constant and a distribution) it throws a runtime error.

The generated bytecode is then kept clean and readable by containing mostly calls to methods of the `Runtime` class.

# Testing

# Extensions

As an extension I have implemented a simple Haskell library for generated Jasmin bytecode. The library contains functions for constructing Jasmin directives such as `.class`, `.field` or `.method` and for instructions inside methods.

This library helps developers avoid mistakes by encoding the bytecode as expressions instead of strings. For example, to generate a `.method` directive we can use a single string:

```
.method public static replicate(ILjava/lang/String;)Ljava/lang/String;
```

However, this form is hard to read and prone to errors. The equivalent Haskell expression is

```
jmethod [MethodPublic, MethodStatic]
  (Method "replicate"
    [TypeInt, TypeObject "java/lang/string"]
    TypeObject "java/lang/String")
```

The library is in `Jasmin.hs` and also contains an example program.
